<!DOCTYPE html>
<html lang="en">
<head>
  <title>Hello, world!</title>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="" />
  <style>
    #myPlot {
      position: relative;
    }

    #myPlot .yLabel {
      position: absolute;
      left: 5px;
      outline: 1px solid red;
      padding: 2px;
      background-color: rgba(100, 100, 100, 0.3);
    }

    #myPlot .yLabel.yMax {
      top: 0px;
    }

    #myPlot .yLabel.yMin {
      bottom: 0px;
    }

    #myPlot .yLabel.yCurrent {
      top: 75px;
      outline-color: blue;
    }
  </style>
</head>
<body>
  <h1>Hello, world!</h1>

  <button id="recordButton">Start Recording</button>
  <span>Received data: <span id="receivedDataLabel"></span></span>

  <div id="myPlot">
    <canvas></canvas>
    <p class="yLabel yMax" contentEditable="true">1</p>
    <p class="yLabel yMin" contentEditable="true">0</p>
    <p class="yLabel yCurrent"></p>
  </div>

  <script>
    class Plot1D {
      constructor(plotId) {
        // HTML elements associated with plot
        this.plot = document.getElementById(plotId);
        this.yMaxLabel = this.plot.getElementsByClassName('yMax')[0];
        this.yMinLabel = this.plot.getElementsByClassName('yMin')[0];
        this.yCurrentLabel = this.plot.getElementsByClassName('yCurrent')[0];

        // canvas to draw plot on
        this.canvas = this.plot.getElementsByTagName('canvas')[0];
        this.context = this.canvas.getContext('2d');

        // coordinate of last plotted point to connect line to new point
        this.prevX = 0;
        this.prevY = 0;

        // queued points to plot
        this.yQueue = [];

        // update Y scale to initial range based on labels
        this.updateYScale();
        // keep Y scale updated as labels change
        this.yMaxLabel.addEventListener('input', (e) => {
          this.updateYScale();
        });
        this.yMinLabel.addEventListener('input', (e) => {
          this.updateYScale();
        });
      }

      // efficiently slide canvas contents by a horizontal amount
      // https://stackoverflow.com/a/36337777 
      slide(slideAmount) {
        this.context.globalCompositeOperation = 'copy';
        this.context.drawImage(this.canvas, -1 * slideAmount, 0);
        this.context.globalCompositeOperation = 'source-over';
        this.context.imageSmoothingEnabled = false;

        this.prevX -= slideAmount;
      }

      // pull points from queue to plot
      refreshPlot() {
        if (this.yQueue.length > 0) {
          this.yCurrentLabel.innerHTML = this.yQueue[0].toFixed(2);
          this.appendYPoints(this.yQueue, 5);
        }
      }

      // set range of Y values for scaling the plot
      setYScale(yMin, yMax) {
        this.yMin = yMin;
        this.yMax = yMax;
        this.yMultiplier = this.canvas.height / (this.yMax - this.yMin);

        this.prevY = this.scaleY(this.prevY);
      }

      // update Y scale based on Y labels
      updateYScale() {
        const yMin = parseFloat(this.yMinLabel.innerHTML);
        const yMax = parseFloat(this.yMaxLabel.innerHTML);

        if (!Number.isNaN(yMin) && !Number.isNaN(yMax)) {
          this.setYScale(yMin, yMax);
        }
      }

      // apply scaling to a Y value
      scaleY(yValue) {
        return (yValue - this.yMin) * this.yMultiplier;
      }

      // draw a new point by connecting a line from the last plotted point
      appendXYPoint(newX, newY) {
        newY = this.scaleY(newY);
        newY = this.canvas.height - newY; // flip Y axis so 0 is on the bottom

        this.context.beginPath();
        this.context.moveTo(this.prevX, this.prevY);
        this.context.lineTo(newX, newY);
        this.context.stroke();

        this.prevX = newX;
        this.prevY = newY;
      }

      // draw a new point using a relative X offset from the last plotted point
      appendYPoint(newY, deltaX) {
        this.appendXYPoint(this.prevX + deltaX, newY);
      }

      // pull points from a queue to plot
      appendYPoints(newYs, deltaX) {
        const numYPoints = newYs.length;

        const yPointsSpaceNeeded = numYPoints * deltaX;
        if (this.prevX + yPointsSpaceNeeded > this.canvas.width) {
          this.slide(this.prevX + yPointsSpaceNeeded - this.canvas.width);
        }

        for (let index = 0; index < numYPoints; index++) {
          const yPoint = newYs.shift();
          this.appendYPoint(yPoint, deltaX);
        }
      }

    }

    const plot = new Plot1D('myPlot');
    plot.canvas.width = 500;
    plot.canvas.height = 200;
    plot.canvas.style.background = 'lightgray';
    plot.setYScale(0, 1);

    setInterval(function() {
      plot.refreshPlot();
    }, 100);

    function getSocketEndpoint() {
      let endpoint = window.location.origin;
      endpoint = endpoint.replace('http://', 'ws://');
      endpoint = endpoint.replace('https://', 'wss://');
      return endpoint + '/sockets/output';
    }

    const receivedDataLabel = document.getElementById('receivedDataLabel');
    const ws = new WebSocket(getSocketEndpoint());
    ws.onmessage = function(event) {
      receivedDataLabel.innerHTML = event.data;
      if (event.data != null) {
        const event_parts = event.data.split(',');
        plot.yQueue.push(parseFloat(event_parts[0]));
      }
    };

    function getRecordingEndpoint(recording) {
      return window.location.origin + '/record?recording=' + recording;
    }

    const recordButton = document.getElementById('recordButton');
    recordButton.addEventListener('click', function() {
      let endpoint = null;
      if (recordButton.innerText === 'Start Recording') {
        endpoint = getRecordingEndpoint(true);
      } else if (recordButton.innerText === 'Stop Recording') {
        endpoint = getRecordingEndpoint(false);
      }

      if (endpoint !== null) {
        fetch(endpoint)
          .then(response => response.text())
          .then(response => {
            response = parseInt(response);
            if (response === 1) {
              document.body.style.background = 'red';
              recordButton.innerText = 'Stop Recording';
            } else if (response === 0) {
              document.body.style.background = 'white';
              recordButton.innerText = 'Start Recording';
            } else if (response === -1) {
              document.body.style.background = 'gray';
              recordButton.innerText = 'Something went wrong';
            }
          });
      }
    });
  </script>
</body>
</html>