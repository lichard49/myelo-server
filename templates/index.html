<!DOCTYPE html>
<html lang="en">
<head>
  <title>Hello, world!</title>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="" />
</head>
<body>
  <h1>Hello, world!</h1>

  <button id="recordButton">Start Recording</button>

  <div>
    <canvas id="myCanvas"></canvas>
  </div>

  <script>
    class Plot1D {
      constructor(canvas) {
        // canvas to draw plot on
        this.canvas = canvas;
        this.context = this.canvas.getContext('2d');

        // coordinate of last plotted point to connect line to new point
        this.prevX = 0;
        this.prevY = 0;

        // queued points to plot
        this.yQueue = [];
      }

      // efficiently slide canvas contents by a horizontal amount
      // https://stackoverflow.com/a/36337777 
      slide(slideAmount) {
        this.context.globalCompositeOperation = 'copy';
        this.context.drawImage(this.canvas, -1 * slideAmount, 0);
        this.context.globalCompositeOperation = 'source-over';
        this.context.imageSmoothingEnabled = false;

        this.prevX -= slideAmount;
      }

      // pull points from queue to plot
      refreshPlot() {
        if (this.yQueue.length > 0) {
          this.appendYPoints(this.yQueue, 5);
        }
      }

      // set range of Y values for scaling the plot
      setYScale(yMin, yMax) {
        this.yMin = yMin;
        this.yMax = yMax;
        this.yMultiplier = this.canvas.height / (this.yMax - this.yMin);

        this.prevY = this.scaleY(this.prevY);
      }

      // apply scaling to a Y value
      scaleY(yValue) {
        return (yValue - this.yMin) * this.yMultiplier;
      }

      // draw a new point by connecting a line from the last plotted point
      appendXYPoint(newX, newY) {
        newY = this.scaleY(newY);

        this.context.beginPath();
        this.context.moveTo(this.prevX, this.prevY);
        this.context.lineTo(newX, newY);
        this.context.stroke();

        this.prevX = newX;
        this.prevY = newY;
      }

      // draw a new point using a relative X offset from the last plotted point
      appendYPoint(newY, deltaX) {
        this.appendXYPoint(this.prevX + deltaX, newY);
      }

      // pull points from a queue to plot
      appendYPoints(newYs, deltaX) {
        const numYPoints = newYs.length;

        const yPointsSpaceNeeded = numYPoints * deltaX;
        if (this.prevX + yPointsSpaceNeeded > this.canvas.width) {
          this.slide(this.prevX + yPointsSpaceNeeded - this.canvas.width);
        }

        for (let index = 0; index < numYPoints; index++) {
          const yPoint = newYs.shift();
          this.appendYPoint(yPoint, deltaX);
        }
      }

    }

    const canvas = document.getElementById('myCanvas');
    const plot = new Plot1D(canvas);
    canvas.width = 500;
    canvas.height = 200;
    canvas.style.background = 'lightgray';
    plot.setYScale(0, 1);

    setInterval(function() {
      plot.refreshPlot();
    }, 100);

    function getSocketEndpoint() {
      let endpoint = window.location.origin;
      endpoint = endpoint.replace('http://', 'ws://');
      endpoint = endpoint.replace('https://', 'wss://');
      return endpoint + '/sockets/output';
    }

    const ws = new WebSocket(getSocketEndpoint());
    ws.onmessage = function(event) {
      // console.log(event);
      if (event.data != null) {
        const event_parts = event.data.split(',');
        plot.yQueue.push(parseFloat(event_parts[0]));
      }
    };

    function getRecordingEndpoint(recording) {
      return window.location.origin + '/record?recording=' + recording;
    }

    const recordButton = document.getElementById('recordButton');
    recordButton.addEventListener('click', function() {
      let endpoint = null;
      if (recordButton.innerText === 'Start Recording') {
        endpoint = getRecordingEndpoint(true);
      } else if (recordButton.innerText === 'Stop Recording') {
        endpoint = getRecordingEndpoint(false);
      }

      if (endpoint !== null) {
        fetch(endpoint)
          .then(response => response.text())
          .then(response => {
            response = parseInt(response);
            if (response === 1) {
              document.body.style.background = 'red';
              recordButton.innerText = 'Stop Recording';
            } else if (response === 0) {
              document.body.style.background = 'white';
              recordButton.innerText = 'Start Recording';
            } else if (response === -1) {
              document.body.style.background = 'gray';
              recordButton.innerText = 'Something went wrong';
            }
          });
      }
    });
  </script>
</body>
</html>